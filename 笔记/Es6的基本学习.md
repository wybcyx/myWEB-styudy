1.let命令的出现
let命令的作用和var是很类似的，是为了声明变量；
区别：
    let的使用时遵循块级作用域，var是全局的变量；
    let是不存在变量提升的，必须先声明在使用；
    let是不可重复定义的，var却可以；
    let存在暂时性死区，（let在声明的同时就是和他所在的块级作用域进行了绑定，在这个区域之外的其他地方都不允许声明相同的变量名，也就是“死区”）
2.const命令
作用：声明一个只读的常量，同时const定义的变量在声明的时候就必须赋值；
const的作用域和let一样，只在所声明的作用域起作用；
本质问题：
    const实质上并不是变量的值不能改变，而是变量指向的内存地址所存储的内容不得改动；
3.顶层对象
    在es6中顶层对象指的是window对象；

4.变量的解构赋值
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

    4.1数组的
    ES6 允许将赋值写成下面这样。
    let [a,b,c]=[1,2,3]//a=1,b=2,c=3

    如果结构不成功，变量的值为undefined
    let [foo] = [];
    //foo=undefined
    let [bar, foo] = [1];
    //foo=undefined

    注意：对于 Set 结构，也可以使用数组的解构赋值。
    let [x, y, z] = new Set(['a', 'b', 'c']);
        x // "a"   

     解构赋值允许指定默认值，当一个数组成员严格等于undefined，才会触发。
     类似于
     let [foo = true] = [];
    foo // true

    let [x, y = 'b'] = ['a']; // x='a', y='b'
    let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

    4.2对象的
    let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
    foo // "aaa"
    bar // "bbb"

    对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

    对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
    4.3字符串的
    4.4数值和boolean的
    4.5函数的参数解构
    4.6圆括号问题
    4.7用途
5、字符串的拓展
    模板字符串1、反向单引号2、${变量名称}
    